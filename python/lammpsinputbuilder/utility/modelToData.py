from ase.io import write, read
from ase.atoms import Atoms

import numpy as np
from pathlib import Path
from typing import List
from lammpsinputbuilder.types import MoleculeFileFormat, Forcefield, ElectrostaticMethod, MoleculeHolder

def extractElementsFromData(dataPath: str) -> str:
    """
    Get the list of elements from the data file to be used by airebo/reax
    """
    with open(dataPath, 'r') as f:
        lines = f.readlines()
    i = 0
    for line in lines:
        if line[:6] == 'Masses':
            ini = i + 2
        if line[:5] == 'Atoms':
            fin = i - 1
        i += 1
    elements = ''
    for line in lines[ini:fin]:
        elements += ' ' + line.split()[-1]
    return elements

def moleculeToLammpsDataPBC(moleculeContent: str, moleculeFileFormat: MoleculeFileFormat, jobFolder:Path, dataFileName: str) -> MoleculeHolder:
    """
    Convert a molecule from XYZ or MOL2 format to a LAMMPS data file.
    TODO: add support for PBC/Shrink
    """

    # Save the molecule file in the job folder
    if moleculeFileFormat == MoleculeFileFormat.MOL2:
        moleculePath = jobFolder / 'molecule.MOL2'
    elif moleculeFileFormat == MoleculeFileFormat.XYZ:
        moleculePath = jobFolder / 'molecule.XYZ'
    else:   # Unreachable but kept in case the file format enum changes
        raise ValueError(f"Unknown molecule file format: {moleculeFileFormat}")

    with open(moleculePath, 'w') as f:
        f.write(moleculeContent)

    atoms = read(moleculePath)

    # Default cell, will be overwritten when rewritting the data file.
    atoms.set_cell([500, 500, 500])

    # Write a temporary data file which doesn't contain mass information yet
    tempDataPath = jobFolder / (str(dataFileName) + '.temp')
    write(filename=tempDataPath, images=atoms, format='lammps-data', atom_style='full')

    # ASE always write the bounding starting from 0,0,0
    # We have to rewrite it manually to handle cases where positions can be in the negative
    # Doing it now avoir the need to translate back the trajectory later on to match the user input.
    positions = np.array(atoms.get_positions())

    xcoords = positions[:,0]
    ycoords = positions[:,1]
    zcoords = positions[:,2]

    xmin = xcoords.min()
    ymin = ycoords.min()
    zmin = zcoords.min()

    xmax = xcoords.max()
    ymax = ycoords.max()
    zmax = zcoords.max()

    padding = 50.0 # Adding 50A for now

    # TODO: check if writting the masses manually is necessary, ASE write has the masses option.
    chemical_symbols = atoms.get_chemical_symbols()
    masses = atoms.get_masses()
    indexes = np.unique(chemical_symbols, return_index=True)[1]
    masses_u = [masses[index] for index in indexes]
    chemical_symbols_u = [chemical_symbols[index] for index in indexes]

    with open(tempDataPath, 'r') as f:
        lines = f.readlines()

    dataPath = jobFolder / str(dataFileName)
    with open(dataPath, 'w') as f:
        f.write('# Generated by LammpsInputBuilder\n')

        # Find the first line which start with a number
        startOffset = 0
        for i in range(len(lines)):
            if len(lines[i].split()) > 0 and lines[i].split()[0].isdigit():
                startOffset = i
                break

        if startOffset > len(lines)-1:
            raise RuntimeError("Could not find the first line in LAMMPS data file")
        
        # Copy the lines until the line ending with zhi is found
        offset = 0
        bboxCoords = [xmin - padding, xmax + padding, ymin - padding, ymax + padding, zmin - padding, zmax + padding]
        for i in range(startOffset, len(lines)):
            #f.write(lines[i])
            #if len(lines[i].split()) > 0 and lines[i].split()[-1] == 'zhi':
            #    break
            if len(lines[i].split()) > 0 and lines[i].split()[-1] == 'xhi':
                f.write(f"{bboxCoords[0]}\t{bboxCoords[1]} xlo xhi\n")
            elif len(lines[i].split()) > 0 and lines[i].split()[-1] == 'yhi':
                f.write(f"{bboxCoords[2]}\t{bboxCoords[3]} ylo yhi\n")
            elif len(lines[i].split()) > 0 and lines[i].split()[-1] == 'zhi':
                f.write(f"{bboxCoords[4]}\t{bboxCoords[5]} zlo zhi\n")
                break
            else:
                f.write(lines[i])
                offset += 1
        if offset > len(lines)-1:
            raise RuntimeError("Could not find zhi in LAMMPS data file")
        

        # Insert the masses in the data file so it doesn't have to be added separatly in the script file
        f.write('\n')
        f.write('Masses\n')
        f.write('\n')
        for i in range(len(masses_u)):
            f.write(f'{i + 1} {masses_u[i]} # {chemical_symbols_u[i]}\n')
        f.write('\n')
        f.write('Atoms # full\n')
        f.write('\n')

        # Find the offset of the Atoms section
        for i in range(offset, len(lines)):
            if lines[i].startswith('Atoms'):
                offset = i+2
                break
        if offset > len(lines)-1:
            raise RuntimeError("Could not find Atoms in LAMMPS data file")

        # Now that the masses are added, we can add the rest of the lines.
        for i in range(offset, len(lines)):
            f.write(lines[i])
    
    return MoleculeHolder(atoms, bboxCoords)

def moleculeToLammpsInput(lammpsScriptFileName:Path, dataFilePath: Path, jobFolder: Path, ffType: Forcefield, forcefieldName:str, molecule: MoleculeHolder, electrostaticMethod: ElectrostaticMethod) -> Path:
        lammpsScriptFilePath = jobFolder / lammpsScriptFileName
        with open(lammpsScriptFilePath, "w") as f:

            # Extract the simulation box
            cellDims = molecule.getBboxDims()
            minCellDim = min([cellDims[0], cellDims[1], cellDims[2]])

            # Get back the list of elements
            elements = extractElementsFromData(dataFilePath)

            scriptContent = "# -*- mode: lammps -*-\n"
            if ffType == Forcefield.REAX:
                scriptContent += 'units          real\n'
            elif ffType in [Forcefield.AIREBO, Forcefield.REBO, Forcefield.AIREBOM]:
                scriptContent += 'units          metal\n'
            else:
                raise NotImplementedError(f"Forcefield {ffType} not supported")
            scriptContent += 'atom_style     full\n'
            scriptContent += 'atom_modify    map hash\n'
            scriptContent += 'newton         on\n'
            scriptContent += 'boundary       p p p\n'

            scriptContent += f'read_data       {dataFilePath.name}\n'
            #for i in range(len(indexes)):
            #    scriptContent += f'mass           {i + 1} {masses_u[i]}\n' 
            
            if ffType == Forcefield.REAX:
                scriptContent += 'pair_style     reaxff NULL mincap 1000\n'
                scriptContent += f'pair_coeff     * * {forcefieldName}{elements}\n'
                if electrostaticMethod == ElectrostaticMethod.ACKS2:
                    scriptContent += 'fix            ReaxFFSpec all acks2/reaxff 1 0.0 10.0 1e-8 reaxff\n'
                elif electrostaticMethod == ElectrostaticMethod.QEQ:
                    scriptContent += 'fix            ReaxFFSpec all qeq/reaxff 1 0.0 10.0 1e-8 reaxff\n'
                else:
                    raise NotImplementedError(f"Electrostatic method {electrostaticMethod} not supported.")
            elif ffType == Forcefield.REBO:
                scriptContent+='pair_style     rebo\n'
                scriptContent+=f'pair_coeff     * * {forcefieldName}{elements}\n'
            elif ffType == Forcefield.AIREBO:
                scriptContent+='pair_style     airebo 3 1 1\n'
                #scriptContent+='pair_style     airebo 3 1 0\n'
                scriptContent+=f'pair_coeff     * * {forcefieldName}{elements}\n'
            elif ffType == Forcefield.AIREBOM:
                scriptContent+='pair_style     airebo/morse 3 1 1\n'
                scriptContent+=f'pair_coeff     * * {forcefieldName}{elements}\n'
            #scriptContent += 'neighbor       2.5 bin\n' 
            # 2.5 is too large for small molecule like benzene. Trying to compute a reasonable cell skin based on the simulation box
            scriptContent += f"neighbor       {min([2.5, minCellDim/2])} bin\n"
            scriptContent += 'neigh_modify   every 1 delay 0 check yes\n'

            scriptContent += 'run            0\n'

            f.write(scriptContent)

            return lammpsScriptFilePath